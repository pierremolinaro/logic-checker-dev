#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#    AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @definition {}

#·······················································································································

abstract method @definition compute ?!@blockMap blockMap

#·······················································································································

list @definitionList {
  @definition mDefinition
}

#·······················································································································

map @blockMap {
  @stringlist mInputVariableList
  @stringlist mOutputVariableList
  @binaryset mStates ;
  @binaryset mTransitions ;
  insert insertKey error message "the '%K' block is already declared in %L"
  search searchKey error message "there is no '%K' block"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#    SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax logicchecker_syntax (logicchecker_lexique) {

  #·····················································································································

  rule <start_symbol> {
    @definitionList definitionList = {}
    repeat
    while
      <definition> ?let definition
      definitionList += !definition
    end
    @blockMap blockMap = {}
    for (definition) in definitionList do
      [definition compute !?blockMap]
    end
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
