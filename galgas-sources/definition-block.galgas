#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#    AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract class @expression {}

#·······················································································································

class @trueExpression : @expression {}

#·······················································································································

class @falseExpression : @expression {}

#·······················································································································

class @varExpression : @expression {
  @lstring mVariableName
}

#·······················································································································

class @negationExpression : @expression {
  @expression mExpression
}

#·······················································································································

class @andExpression, @orExpression, @xorExpression : @expression {
  @expression mLeftExpression
  @expression mRightExpression
}

#·······················································································································

list @assignmentList {
  @lstring mTargetName
  @expression mExpression
}

#·······················································································································

class @blockDefinition : @definition {
  @lstring mBlockName
  @lstringlist mInputVariableList
  @lstringlist mOutputVariableList
  @assignmentList mAssignmentList
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#    SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension logicchecker_syntax {

  #·····················································································································

  rule <definition> !@definition outDefinition {
    $block$
    $identifier$ ?let blockName
    $($
    @lstringlist inputVariableList = {}
    repeat
      $identifier$ ?let inputName
      inputVariableList += !inputName
    while
      $,$
    end
    $)$
    $->$
    $($
    @lstringlist outputVariableList = {}
    repeat
      $identifier$ ?let outputName
      outputVariableList += !outputName
    while
      $,$
    end
    $)$
    ${$
    @assignmentList assignmentList = {}
    repeat
      <expression> ?let expression
      $->$
      $identifier$ ?let targetName
      assignmentList += !targetName !expression
    while
      $,$
    end
    $}$
    outDefinition = @blockDefinition.new {!blockName !inputVariableList !outputVariableList !assignmentList}
  }

  #·····················································································································

  rule <expression> !@expression outExpression {
    <terme> ?outExpression
    repeat
    while
      $|$
      <terme> ?let expression
      outExpression = @orExpression.new {!outExpression !expression}
    while
      $^$
      <terme> ?let expression
      outExpression = @xorExpression.new {!outExpression !expression}
    end
  }
  
  #·····················································································································

  rule <terme> !@expression outExpression {
    <factor> ?outExpression
    repeat
    while
      $&$
      <factor> ?let expression
      outExpression = @andExpression.new {!outExpression !expression}
    end
  }
  
  #·····················································································································

  rule <factor> !@expression outExpression {
    $/$
    <factor> ?let expression
    outExpression = @negationExpression.new {!expression}
  }
  
  #·····················································································································

  rule <factor> !@expression outExpression {
    $identifier$ ?let variableName
    outExpression = @varExpression.new {!variableName}
  }
  
   #·····················································································································

  rule <factor> !@expression outExpression {
    $($
    <expression> ?outExpression
    $)$
  }
  
  #·····················································································································

  rule <factor> !@expression outExpression {
    $true$
    outExpression = @trueExpression.new
  }
  
  #·····················································································································

  rule <factor> !@expression outExpression {
    $false$
    outExpression = @falseExpression.new
  }
  
  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

map @variableMap {
  @uint mIndex
  insert insertKey error message "the '%K' variable is already declared in %L"
  search searchKey error message "there is no '%K' variable"
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   STATE COMPUTING
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @expression computeStateExpression ?let @variableMap inVariableMap -> @binaryset

#·······················································································································

override getter @falseExpression computeStateExpression ?let @variableMap unused inVariableMap -> @binaryset {
  result = @binaryset.emptyBinarySet
}

#·······················································································································

override getter @trueExpression computeStateExpression ?let @variableMap unused inVariableMap -> @binaryset {
  result = @binaryset.fullBinarySet
}

#·······················································································································

override getter @negationExpression computeStateExpression ?let @variableMap inVariableMap -> @binaryset {
  result = ~ [mExpression  computeStateExpression !inVariableMap]
}

#·······················································································································

override getter @varExpression computeStateExpression ?let @variableMap inVariableMap -> @binaryset {
  [inVariableMap searchKey !mVariableName ?let varIndex]
  result = @binaryset.binarySetWithBit {!varIndex}
}

#·······················································································································

override getter @andExpression computeStateExpression ?let @variableMap inVariableMap -> @binaryset {
  let left  = [mLeftExpression  computeStateExpression !inVariableMap]
  let right = [mRightExpression computeStateExpression !inVariableMap]
  result = left & right
}

#·······················································································································

override getter @orExpression computeStateExpression ?let @variableMap inVariableMap -> @binaryset {
  let left  = [mLeftExpression  computeStateExpression !inVariableMap]
  let right = [mRightExpression computeStateExpression !inVariableMap]
  result = left | right
}

#·······················································································································

override getter @xorExpression computeStateExpression ?let @variableMap inVariableMap -> @binaryset {
  let left  = [mLeftExpression  computeStateExpression !inVariableMap]
  let right = [mRightExpression computeStateExpression !inVariableMap]
  result = left ^ right
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   TRANSITION COMPUTING
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

abstract getter @expression computeTransitionExpression
  ?let @variableMap unused inVariableMap
  ?let @uint unused inOutputVarCount -> @binaryset

#·······················································································································

override getter @falseExpression computeTransitionExpression 
  ?let @variableMap unused inVariableMap
  ?let @uint unused inOutputVarCount -> @binaryset {
  result = @binaryset.emptyBinarySet
}

#·······················································································································

override getter @trueExpression computeTransitionExpression 
  ?let @variableMap unused inVariableMap
  ?let @uint unused inOutputVarCount -> @binaryset {
  result = @binaryset.fullBinarySet
}

#·······················································································································

override getter @negationExpression computeTransitionExpression
  ?let @variableMap inVariableMap
  ?let @uint inOutputVarCount -> @binaryset
{
  result = ~ [mExpression  computeTransitionExpression !inVariableMap !inOutputVarCount]
}

#·······················································································································

override getter @varExpression computeTransitionExpression 
  ?let @variableMap inVariableMap
  ?let @uint inOutputVarCount -> @binaryset
{
  [inVariableMap searchKey !mVariableName ?let varIndex]
  if varIndex >= inOutputVarCount then # An input variable ?
    result = @binaryset.binarySetWithBit {!varIndex + [inVariableMap count]}
  else
    result = @binaryset.binarySetWithBit {!varIndex}
  end
}

#·······················································································································

override getter @andExpression computeTransitionExpression 
  ?let @variableMap inVariableMap
  ?let @uint inOutputVarCount -> @binaryset
{
  let left  = [mLeftExpression  computeTransitionExpression !inVariableMap !inOutputVarCount]
  let right = [mRightExpression computeTransitionExpression !inVariableMap !inOutputVarCount]
  result = left & right
}

#·······················································································································

override getter @orExpression computeTransitionExpression 
  ?let @variableMap inVariableMap
  ?let @uint inOutputVarCount -> @binaryset
{
  let left  = [mLeftExpression  computeTransitionExpression !inVariableMap !inOutputVarCount]
  let right = [mRightExpression computeTransitionExpression !inVariableMap !inOutputVarCount]
  result = left | right
}

#·······················································································································

override getter @xorExpression computeTransitionExpression 
  ?let @variableMap inVariableMap
  ?let @uint inOutputVarCount -> @binaryset
{
  let left  = [mLeftExpression  computeTransitionExpression !inVariableMap !inOutputVarCount]
  let right = [mRightExpression computeTransitionExpression !inVariableMap !inOutputVarCount]
  result = left ^ right
}

#·······················································································································

override method @blockDefinition compute
  ?!@blockMap blockMap
  ?let @string unused inSourceFile
{
  message "--------------- Block " + mBlockName + "\n"
  let variableCount = [mInputVariableList length] + [mOutputVariableList length]
  @variableMap variableMap = {}
  @variableMap outputVariableMap = {}
  @stringlist inputVariableList = {}
  for (name) in mInputVariableList do
    [!?variableMap insertKey !name !variableCount - [variableMap count] - 1]
    inputVariableList += !name.string
  end
#  let inputVarCount = [inputVariableList length]
  @stringlist outputVariableList = {}
  for (name) in mOutputVariableList do
    let variableIndex = variableCount - [variableMap count] - 1
    [!?variableMap insertKey !name !variableIndex]
    [!?outputVariableMap insertKey !name !variableIndex]
    outputVariableList += !name.string
  end
  let outputVarCount = [outputVariableList length]
  @stringset assignedOutputVariableSet = {}
  for (targetVar expression) in mAssignmentList do
    [variableMap searchKey !targetVar ?*]
    if not [outputVariableMap hasKey !targetVar.string] then
      error targetVar : "this variable should be an output variable"
    elsif [assignedOutputVariableSet hasKey !targetVar.string] then
      error targetVar : "output variable has been already assigned"
    end
    assignedOutputVariableSet += !targetVar.string
  end
  for (unassignedVar) in [outputVariableMap keySet] - assignedOutputVariableSet do
    error [outputVariableMap locationForKey !unassignedVar] : "this output variable should be assigned"
  end
#  log variableMap
#--- Compute BDD
  var blockStates = @binaryset.fullBinarySet
  var blockTransitions = @binaryset.emptyBinarySet
  for (targetVar expression) in mAssignmentList do
  #--- Target var BDD
    [variableMap searchKey !targetVar ?let targetVarIndex]
  #--- Accumulate state
    let stateExpressionBDD = [expression computeStateExpression !variableMap]
    let targetVarBDD = @binaryset.binarySetWithBit {!targetVarIndex}
    blockStates = blockStates & [targetVarBDD equalTo !stateExpressionBDD]
  #--- Accumulate transitions
    let transitionExpressionBDD = [expression computeTransitionExpression !variableMap !outputVarCount]
    let shiftedTargetVarBDD = @binaryset.binarySetWithBit {!targetVarIndex + variableCount}
    blockTransitions = blockTransitions | [shiftedTargetVarBDD equalTo !transitionExpressionBDD]
  end
#--- Constraint with stable source states
  blockTransitions = blockTransitions & blockStates
#--- Constraint with stable target states
  blockTransitions = blockTransitions & (blockStates << variableCount)
#--- Display states result
  message [[blockStates valueCount !variableCount] string]
      + " states (" + [[blockStates nodeCount] string] + " BDD nodes)\n"
#--- Display transitions
  message [[blockTransitions valueCount !2* variableCount] string] + " transitions (" +
     [[blockTransitions nodeCount] string] + " BDD nodes)\n"
#--- Enter in block map
  [!?blockMap insertKey !mBlockName !inputVariableList !outputVariableList !blockStates !blockTransitions]
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

