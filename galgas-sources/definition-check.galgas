#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#    AST
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

class @checkDefinition : @definition {
  @lstring mBlockName
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#    SYNTAX
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

syntax extension logicchecker_syntax {

  #·····················································································································

  rule <definition> !@definition outDefinition {
    $check$
    $identifier$ ?let blockName
    outDefinition = @checkDefinition.new {!blockName}
  }

  #·····················································································································

}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————
#   SEMANTICS
#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

override method @checkDefinition compute ?!@blockMap blockMap ?let @string unused inSourceFile {
  message "--------------- Check " + mBlockName + "\n"
  [blockMap searchKey
    !mBlockName
    ?let inputVariableList
    ?let outputVariableList
    ?let states
    ?let transitions
  ]
  let outputVarCount = [outputVariableList length]
  let inputVarCount = [inputVariableList length]
  let variableCount = inputVarCount + outputVarCount
#  log inputVarCount, outputVarCount
#------------------------------ Check states are complete
# Ensemble des états complets : ∃s', ∀e' : (e, s) -> (e', s') est une transition et ((e, s) un état
  var tr = transitions
#  log tr
  tr = [tr existsOnBitRange !variableCount !outputVarCount]
#  message "" + [tr valueCount !2*variableCount] + " temp1 states (" + [tr nodeCount]
#       + " BDD nodes):\n"
  tr = [tr forAllOnBitIndexAndBeyond !variableCount]
#  message "" + [tr valueCount !variableCount] + " temp2 states (" + [tr nodeCount]
#       + " BDD nodes):\n"
  let incompleteStates = states & ~ tr
  let incompleteStateCount = [incompleteStates valueCount !variableCount]
  if incompleteStateCount == 0 then
    message "All states are complete\n"
  else
    error.nowhere : ""
       + incompleteStateCount + " incomplete state" + if incompleteStateCount > 1 then "s" else "" end + " ("
       + [incompleteStates nodeCount]
       + " BDD nodes):"
    var line = "  "
    for (s) in inputVariableList do
      line += " " + s
    end
    line += " :"
    for (s) in outputVariableList do
      line += " " + s
    end
    message line + "\n"
    let stateList = [incompleteStates compressedStringValueList !variableCount]
    for (s) in stateList do
      var compressedString = s
      line = "  "
      for (varName) in inputVariableList do
        [!?compressedString removeCharacterAtIndex ?let char !0]
        line += @string.stringWithSequenceOfCharacters {!' ' ![varName length] - 1}
        line += " " + char
      end
      line += " :"
      for (varName) in outputVariableList do
        [!?compressedString removeCharacterAtIndex ?let char !0]
        line += @string.stringWithSequenceOfCharacters {!' ' ![varName length] - 1}
        line += " " + char
      end
      message line + "\n"
    end
  end
#------------------------------ Check no ambiguous transition
# Ensemble des transitions ambiguës :
# ∀(e, s) état, ∃(e, s) -> (e', s') transition, ∃(e, s) -> (e", s") transition et e' = e" et s' != s"
  var result = transitions & [transitions binarySetByTranslatingFromIndex !variableCount !variableCount]
#--- Constraint e' = e"
  let inputConstraint = @binaryset.binarySetWithEqualComparison {
    !variableCount + outputVarCount # e'
    !inputVarCount
    !2 * variableCount + outputVarCount # e"
  }
  result = result & inputConstraint
#--- Constraint s' ≠ s"
  let outputConstraint = @binaryset.binarySetWithNotEqualComparison {
    !variableCount # s'
    !outputVarCount
    !2 * variableCount # s"
  }
  result = result & outputConstraint
#--- Suppress (e", s")
  result = [result existOnBitIndexAndBeyond !2 * variableCount]
#--- Ambiguous transition count
  let ambiguousTransitionCount = [result valueCount !2 * variableCount]
#--- Display ampbiguous transitions
  if ambiguousTransitionCount == 0 then
    message "No ambiguous transition.\n"
  else
    error .nowhere :
      [ambiguousTransitionCount string]
      + " ambiguous transition" + if ambiguousTransitionCount > 1 then "s" else "" end + " ("
      + [[result nodeCount] string]
      + " BDD nodes)n"
    var line = " "
    for (s) in inputVariableList do
      line += " " + s
    end
    line += " :"
    for (s) in outputVariableList do
      line += " " + s
    end
    line += "  --> "
    for (s) in inputVariableList do
      line += " " + s
    end
    line += " :"
    for (s) in outputVariableList do
      line += " " + s
    end
    message line + "\n"
    let transitionList = [result compressedStringValueList !2 * variableCount]
    for (s) in transitionList do
      var compressedString = s
      var destString = " "
      for (varName) in inputVariableList do
        [!?compressedString removeCharacterAtIndex ?let char !0]
        destString += @string.stringWithSequenceOfCharacters {!' ' ![varName length] - 1}
        destString += " " + [char string]
      end
      destString += " :"
      for (varName) in outputVariableList do
        [!?compressedString removeCharacterAtIndex ?let char !0]
        destString += @string.stringWithSequenceOfCharacters {!' ' ![varName length] - 1}
        destString += " " + [char string]
      end
      var sourceString = " "
      for (varName) in inputVariableList do
        [!?compressedString removeCharacterAtIndex ?let char !0]
        sourceString += @string.stringWithSequenceOfCharacters {!' ' ![varName length] - 1}
        sourceString += " " + [char string]
      end
      sourceString += " :"
      for (varName) in outputVariableList do
        [!?compressedString removeCharacterAtIndex ?let char !0]
        sourceString += @string.stringWithSequenceOfCharacters {!' ' ![varName length] - 1}
        sourceString += " " + [char string]
      end
      message sourceString + "  -->" + destString + "\n"
    end
  end
}

#———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————

